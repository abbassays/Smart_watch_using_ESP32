// This code will light an LED (as an alarm) on the selected time

#include <Arduino.h>
#include <ESPAsyncWebServer.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <WiFi.h>
#include <NTPClient.h>
#include <WiFiUdp.h>

// C array of my image that will display when setting up the OLED
static const uint8_t ali_map[] = {
  0x81, 0x5c, 0x67, 0xff, 	/*Color of index 0*/
  0xc0, 0xab, 0xbc, 0xff, 	/*Color of index 1*/

  0x15, 0x55, 0x02, 0x55, 0x5f, 0xbf, 0xff, 0xff, 0x00, 0x00, 0x01, 0x40, 0x00, 0xa0, 0x00, 0x40,  
  0x82, 0xa8, 0xd5, 0x2a, 0xb5, 0xd5, 0x7f, 0xff, 0x00, 0x80, 0x45, 0x50, 0x00, 0x20, 0x00, 0x90,  
  0x55, 0x55, 0x70, 0x55, 0x7f, 0xff, 0xff, 0xff, 0x00, 0x00, 0x05, 0x60, 0x00, 0x00, 0x00, 0x48,  
  0x0a, 0xaa, 0xf5, 0x2d, 0x57, 0xeb, 0xff, 0xff, 0x00, 0x0a, 0x02, 0xbc, 0x00, 0x00, 0x00, 0x05,  
  0x57, 0xaa, 0xf8, 0x55, 0x6b, 0xff, 0xff, 0xff, 0x00, 0x05, 0x01, 0x56, 0x00, 0x00, 0x00, 0x00,  
  0x2a, 0xab, 0x7e, 0xae, 0xbe, 0x57, 0xff, 0xfe, 0x00, 0x00, 0x2a, 0xab, 0x80, 0x00, 0x00, 0x01,  
  0x53, 0xaa, 0xbd, 0x55, 0xdf, 0x5b, 0xff, 0xfa, 0x00, 0x00, 0x05, 0xa3, 0xe0, 0x00, 0x00, 0x00,  
  0x00, 0x75, 0xff, 0x6b, 0x57, 0xaa, 0xff, 0xf5, 0x00, 0x00, 0x00, 0x50, 0x50, 0x1e, 0x84, 0x00,  
  0x00, 0x05, 0x5f, 0xb5, 0xef, 0xf7, 0xbf, 0xca, 0x00, 0x00, 0x00, 0x55, 0xbf, 0xf5, 0x70, 0x00,  
  0x00, 0x00, 0xdf, 0xdf, 0x77, 0xff, 0xfc, 0x05, 0x00, 0x00, 0x00, 0x0a, 0x3f, 0xd5, 0x00, 0x00,  
  0x00, 0x00, 0x5d, 0xd7, 0xff, 0xfb, 0xf8, 0x12, 0x00, 0x00, 0x00, 0x06, 0xaf, 0x60, 0x00, 0x00,  
  0x00, 0x00, 0x37, 0xfb, 0x7f, 0xfe, 0x02, 0x0a, 0x00, 0x00, 0x01, 0x01, 0x55, 0x00, 0x00, 0x00,  
  0x00, 0x00, 0x2f, 0x7b, 0xff, 0xf8, 0x00, 0x12, 0x00, 0x00, 0x02, 0xc0, 0x55, 0x00, 0x00, 0x00,  
  0x00, 0x00, 0x0b, 0xfe, 0x84, 0x00, 0x05, 0x4a, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00,  
  0x00, 0x00, 0x02, 0xbe, 0x10, 0x00, 0x20, 0x55, 0x20, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00,  
  0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x95, 0x48, 0x04, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00, 0x00,  
  0x00, 0x00, 0x00, 0xaa, 0xa8, 0x20, 0xa8, 0xaa, 0x02, 0x80, 0x00, 0x3f, 0x80, 0x00, 0x00, 0x00,  
  0x00, 0x00, 0x00, 0x54, 0x02, 0x42, 0x55, 0x54, 0x00, 0xa0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,  
  0x00, 0x00, 0x01, 0x28, 0x84, 0x81, 0x20, 0x02, 0x02, 0xa0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,  
  0x00, 0x00, 0x01, 0x7d, 0x2b, 0xaa, 0x8a, 0xa9, 0x01, 0x50, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,  
  0x00, 0x00, 0x02, 0xdd, 0x5d, 0x55, 0x20, 0x02, 0x80, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,  
  0x40, 0x00, 0x01, 0xfb, 0xf7, 0xae, 0x9b, 0x55, 0x01, 0x50, 0x00, 0x00, 0x80, 0x00, 0x05, 0x00,  
  0x25, 0x00, 0x00, 0x3f, 0xef, 0x5d, 0x76, 0x92, 0x40, 0x10, 0x00, 0x00, 0x40, 0x00, 0x3f, 0x5b,  
  0x80, 0xa0, 0x00, 0xf7, 0xed, 0xaa, 0xfa, 0xab, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfa,  
  0x52, 0xa0, 0x00, 0xbf, 0xfa, 0xdd, 0xfb, 0xb7, 0x20, 0x08, 0x80, 0x00, 0x40, 0x00, 0xff, 0xff,  
  0xa8, 0xa8, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x54, 0x00, 0x00, 0x01, 0xff, 0xfd,  
  0xff, 0x78, 0x01, 0x7f, 0xff, 0xdf, 0xff, 0xff, 0x00, 0x05, 0x15, 0x00, 0x00, 0x01, 0xff, 0xfb,  
  0xfd, 0x5c, 0x00, 0xff, 0xff, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x42, 0xd0, 0x00, 0x01, 0xff, 0xff,  
  0xf7, 0xfc, 0x01, 0x7f, 0xff, 0xff, 0x6f, 0xff, 0x00, 0x00, 0x15, 0x74, 0x00, 0x03, 0xff, 0xff,  
  0xfa, 0xae, 0x00, 0xff, 0xff, 0xfe, 0xff, 0xff, 0x00, 0x00, 0x20, 0xae, 0x80, 0x03, 0xff, 0xff,  
  0xe8, 0x0b, 0x01, 0xff, 0xff, 0xfd, 0xff, 0xff, 0x00, 0x0a, 0x94, 0x77, 0xe8, 0x07, 0xff, 0xff,  
  0xa0, 0x00, 0x80, 0xff, 0xff, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x20, 0x0b, 0xf8, 0x07, 0xfe, 0xbe,  
  0x40, 0x05, 0x01, 0xff, 0xff, 0xff, 0xdf, 0xff, 0x00, 0x0a, 0x94, 0x06, 0xfc, 0x0f, 0xe0, 0x0b,  
  0x80, 0x54, 0x89, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x2a, 0xaa, 0xbc, 0x0f, 0xa0, 0x2a,  
  0x00, 0x2f, 0x45, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x45, 0x54, 0x55, 0x7c, 0x0f, 0xd0, 0x00,  
  0x10, 0x07, 0x04, 0x3f, 0xff, 0xff, 0xff, 0xff, 0x01, 0x11, 0x55, 0xab, 0xde, 0x06, 0x7c, 0x38,  
  0x00, 0x7f, 0x40, 0x0f, 0xff, 0xff, 0xff, 0xff, 0x00, 0x02, 0x55, 0x4a, 0x7f, 0x01, 0xa8, 0x09,  
  0xc1, 0x5f, 0x24, 0x03, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01, 0xfa, 0xb5, 0xff, 0xcc, 0xfa, 0x1b,  
  0xc0, 0x57, 0x40, 0x01, 0xff, 0xff, 0xff, 0xff, 0x08, 0x07, 0xfd, 0x55, 0x57, 0xcf, 0xf5, 0x1b,  
  0xd0, 0x2f, 0xc0, 0x00, 0x45, 0xff, 0xff, 0xff, 0xc2, 0x8f, 0xe7, 0x8a, 0xff, 0x47, 0x6f, 0xe7,  
  0xe1, 0x57, 0xc0, 0x00, 0x2b, 0x5f, 0xff, 0xff, 0xe0, 0x0f, 0xe3, 0xea, 0xff, 0xe7, 0xf7, 0xbf,  
  0xd5, 0x7f, 0xc0, 0x11, 0x5f, 0xff, 0xff, 0xff, 0xfe, 0x01, 0xf3, 0xf5, 0xae, 0x3f, 0xfb, 0x8f,  
  0xe1, 0x5f, 0x40, 0x05, 0x55, 0xff, 0xbf, 0xff, 0x7f, 0xd4, 0xf8, 0xfa, 0x2c, 0x3b, 0xfd, 0x5f,  
  0xd4, 0xff, 0xc0, 0x01, 0x7f, 0xff, 0xff, 0xff, 0xaf, 0xef, 0x77, 0xaf, 0xf0, 0x1f, 0xfe, 0x9f,  
  0xd5, 0x7f, 0x80, 0x81, 0xff, 0xff, 0xdf, 0xff, 0x07, 0xfa, 0x9f, 0x00, 0x00, 0x07, 0xff, 0x5f,  
  0xf5, 0x7f, 0x80, 0x46, 0x0f, 0xff, 0xf7, 0xff, 0x42, 0xff, 0x7f, 0xf0, 0x00, 0x01, 0xff, 0x5f,  
  0xe9, 0x7f, 0x80, 0x22, 0xaf, 0xff, 0xff, 0xff, 0x10, 0x1a, 0x7f, 0xdf, 0xf8, 0x01, 0xff, 0x5b,  
  0x04, 0xbf, 0x00, 0x95, 0xff, 0xff, 0xf7, 0xff, 0x40, 0x81, 0xff, 0x80, 0xa8, 0x08, 0xff, 0xbe,  
  0x2b, 0x7f, 0x03, 0xab, 0xff, 0xff, 0xff, 0xff, 0xa8, 0x23, 0xff, 0x2a, 0xb4, 0x0c, 0xff, 0x7f,  
  0xd4, 0x3f, 0x0f, 0x17, 0xbf, 0xff, 0xfd, 0xff, 0x55, 0x4f, 0xff, 0xd0, 0x0a, 0x0f, 0x7e, 0xff,  
  0xfe, 0x7f, 0x3f, 0xd7, 0x07, 0xff, 0xff, 0xff, 0xa5, 0x3f, 0xff, 0xa4, 0x04, 0x27, 0x7f, 0x06,  
  0xf0, 0xfe, 0xff, 0x54, 0x1f, 0xff, 0xff, 0xf7, 0xb8, 0xff, 0xff, 0xd7, 0xb8, 0x0b, 0x3f, 0xfd,  
  0x01, 0xfc, 0xff, 0xcc, 0x3f, 0xff, 0xff, 0xd7, 0x61, 0xff, 0xff, 0xe2, 0xd0, 0x07, 0x9f, 0xfe,  
  0xff, 0xf8, 0xff, 0x30, 0x3f, 0xff, 0xff, 0xfa, 0x03, 0xff, 0xff, 0xd5, 0x30, 0x0b, 0x8f, 0xff,  
  0xff, 0xf8, 0xff, 0xc0, 0x1f, 0xff, 0xff, 0xf5, 0x07, 0xff, 0xff, 0xea, 0x20, 0x07, 0x8f, 0xff,  
  0xff, 0xf0, 0x7f, 0xa1, 0x0f, 0xff, 0xff, 0xf2, 0x03, 0xff, 0xff, 0xff, 0xc0, 0x05, 0x87, 0xff,  
  0x57, 0xe0, 0x7f, 0xc2, 0x07, 0xff, 0xff, 0xf5, 0x01, 0xff, 0xfb, 0xff, 0xc0, 0x07, 0x83, 0xff,  
  0xff, 0xc0, 0x07, 0x88, 0x01, 0xff, 0xff, 0xea, 0x01, 0xff, 0xef, 0xd7, 0xc0, 0x01, 0x41, 0xff,  
  0xff, 0xc0, 0x02, 0x28, 0x01, 0xff, 0xff, 0xd5, 0x01, 0xff, 0xff, 0xd3, 0xf0, 0x01, 0x80, 0xff,  
  0xff, 0x00, 0x00, 0x20, 0x01, 0xff, 0xff, 0xaa, 0x00, 0x5f, 0xfc, 0x7f, 0xf8, 0x00, 0x00, 0x7f,  
  0xff, 0x00, 0x00, 0xa0, 0x01, 0xff, 0xff, 0x55, 0x00, 0x2f, 0xf0, 0xff, 0xfc, 0x00, 0x00, 0x3f,  
  0xf0, 0x00, 0x02, 0x80, 0x52, 0xff, 0xff, 0x4a, 0x00, 0x0a, 0x95, 0xff, 0xfe, 0x00, 0x00, 0x1f,  
  0xaa, 0xa0, 0x0a, 0x85, 0x05, 0x7f, 0xfc, 0x95, 0x00, 0x02, 0x7b, 0x7f, 0xfe, 0x00, 0x00, 0x0f,  
  0x54, 0x00, 0x14, 0x2a, 0xaa, 0xff, 0xed, 0x4a, 0x00, 0x03, 0xf8, 0xbf, 0xfe, 0x00, 0x00, 0x07,  
};

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
// digital pin 4 has a pushbutton attached to it. Give it a name:
int pushButton = 4;
// LONG PRESS VARIABLES
static const int buttonPin = 4; // switch pin
int buttonStatePrevious = LOW;  // previousstate of the switch

unsigned long minButtonLongPressDuration = 3000; // Time we wait before we see the press as a long press
unsigned long buttonLongPressMillis;             // Time in ms when we the button was pressed
bool buttonStateLongPress = false;               // True if it is a long press
const int intervalButton = 50;      // Time between two readings of the button state
unsigned long previousButtonMillis; // Timestamp of the latest reading

unsigned long buttonPressDuration;

unsigned long currentMillis; // Variabele to store the number of milleseconds since the Arduino has started
// Variables to save date and time
String form_time;
String live_time;
String formattedDate;

void notFound(AsyncWebServerRequest *request);
void ring_alarm(int LED_BUILTIN, int time);
void readButtonState();
void send_email(const char *event);
String format_date(String raw_date);
String format_time(String raw_time);
void oledDisplayCenter(String text);
void setupDisplay();
void setupDisplayStyle(int size, int X, int Y);

// Define NTP Client to get time
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP);
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);
AsyncWebServer server(80);

// REPLACE WITH YOUR NETWORK CREDENTIALS
const char *ssid = "Qamar Abbas Shah";
const char *password = "Alishah786";
const char *host = "maker.ifttt.com";
const char *apiKey = "dQru8C5MlOVIjwd_AvbTbjNaodmKPTopBzA0sX25zY7";

const char *alarm_time_parameter = "alarmTime";

// HTML web page to take time as a input
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE HTML><html><head>
  <title>ESP Input Form</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  </head><body>
  <h1>Set Alarm on Smart Watch</h1>
  <form action="/get">
    Select a time to set alarm: <input type="datetime-local" name="alarmTime">
    <input type="submit" value="Submit">
  </form>
</body></html>)rawliteral";




void setup()
{
  // start serial monitor
  Serial.begin(115200);
  // start display
  setupDisplay();
  // start WiFi
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.println("Connecting to WiFi...");
  if (WiFi.waitForConnectResult() != WL_CONNECTED)
  {
    Serial.println("WiFi Failed!");
    oledDisplayCenter("Press EN button");
    return;
  }
  Serial.print("Connected to IP Address: ");
  Serial.println(WiFi.localIP());
  // Initialize a NTPClient to get time
  timeClient.begin();
  // Pak time is 5 hours ahead of GMT so 5 * 3600s
  timeClient.setTimeOffset(5 * 3600);

  // Send web page with input fields to client
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request)
            { request->send_P(200, "text/html", index_html); });

  // Send a GET request to <ESP_IP>/get?input1=<form_time>
  server.on("/get", HTTP_GET, [](AsyncWebServerRequest *request)
            {
    String alarm_time;
    // GET alarmTime value on <ESP_IP>/get?alarmTime=<form_time>
    if (request->hasParam(alarm_time_parameter)) {
      form_time = request->getParam(alarm_time_parameter)->value();
      form_time = form_time + ":00Z";
      alarm_time = alarm_time_parameter;

    } else {
      form_time = "No message sent";
      alarm_time = "none";
    }
    Serial.print("No format: ");
    Serial.println(form_time);
    Serial.print("Alarm set for: ");
    Serial.print(format_date(form_time));
    Serial.print(format_date("  "));
    Serial.println(format_time(form_time));
    request->send(200, "text/html", "Current time: " + format_date(timeClient.getFormattedDate()) + " " +  format_time(timeClient.getFormattedDate()) + "<br>Alarm set for: " + format_date(form_time) + " " + format_time(form_time) + "<br><a href=\"/\">Reset Alarm</a>"); });


  server.onNotFound(notFound);
  server.begin();
}

void loop()
{
  // update time constantly
  while (!timeClient.update())
  {
    timeClient.forceUpdate();
  }

  // The live_time comes with the following format:
  // 2018-05-28T16:00:13Z
  live_time = timeClient.getFormattedDate();

  display.clearDisplay();
  // need to position text everytime in loop
  // oledDisplayCenter(format_date(live_time));
  setupDisplayStyle(1, 40, 24);
  display.print(format_time(live_time));
  setupDisplayStyle(1, 34, 32);
  display.print(format_date(live_time));
  display.display();
  delay(1000);

  if (live_time == form_time)
  {
    Serial.println("ALARM RINGING");
    // Blink led/buzzer for 60 secs
    ring_alarm(32, 60);
  }
  currentMillis = millis(); // store the current time
  readButtonState();        // read the button state
}


// -------------------------------------------------------------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------------------------------------------------------------
void notFound(AsyncWebServerRequest *request)
{
  request->send(404, "text/plain", "Not found");
}
void oledDisplayCenter(String text)
{
  int16_t x1;
  int16_t y1;
  uint16_t width;
  uint16_t height;

  display.getTextBounds(text, 0, 0, &x1, &y1, &width, &height);

  // display on horizontal and vertical center
  display.clearDisplay(); // clear display
  display.setTextSize(1);
  display.setTextColor(WHITE);
  // to display center axis of a text
  // Serial.print("X: ");
  // Serial.print((SCREEN_WIDTH - width) / 2);
  // Serial.print("  Y: ");
  // Serial.println((SCREEN_HEIGHT - height) / 2);
  display.setCursor((SCREEN_WIDTH - width) / 2, (SCREEN_HEIGHT - height) / 2);
  display.println(text); // text to display
  display.display();
}
String format_date(String raw_date)
{
  // Extract date
  int splitT = raw_date.indexOf("T");
  String dayStamp = raw_date.substring(0, splitT);
  return dayStamp;
}
String format_time(String raw_time)
{
  // Extract time
  int splitT = raw_time.indexOf("T");
  String timeStamp = raw_time.substring(splitT + 1, raw_time.length() - 1);
  return timeStamp;
}
void setupDisplayStyle(int size, int X, int Y)
{
  display.setTextSize(size);
  display.setTextColor(WHITE);
  display.setCursor(X, Y);
}
void setupDisplay()
{
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C))
  { // Address 0x3D for 128x64
    Serial.println(F("SSD1306 allocation failed"));
    for (;;)
      ;
  }
  delay(2000);
  // clear display before starting
  display.clearDisplay();
  // Draw bitmap on the screen
  display.drawBitmap(0, 0, ali_map, 128, 64, 1);
  display.display();
  delay(3000);
  oledDisplayCenter("dev by abbassays");
  delay(3000);
}
void readButtonState()
{
  if (currentMillis - previousButtonMillis > intervalButton)
  {
    // Read the digital value of the button (LOW/HIGH)
    int buttonState = digitalRead(buttonPin);
    // If the button has been pushed AND
    // If the button wasn't pressed before AND
    // IF there was not already a measurement running to determine how long the button has been pressed
    if (buttonState == HIGH && buttonStatePrevious == LOW && !buttonStateLongPress)
    {
      buttonLongPressMillis = currentMillis;
      buttonStatePrevious = HIGH;
      Serial.println("Button pressed");
    }
    // Calculate how long the button has been pressed
    buttonPressDuration = currentMillis - buttonLongPressMillis;
    // If the button is pressed AND
    // If there is no measurement running to determine how long the button is pressed AND
    // If the time the button has been pressed is larger or equal to the time needed for a long press
    if (buttonState == HIGH && !buttonStateLongPress && buttonPressDuration >= minButtonLongPressDuration)
    {
      buttonStateLongPress = true;
      Serial.println("Button long pressed");

      send_email("SOS_email");
    }
    // If the button is released AND
    // If the button was pressed before
    if (buttonState == LOW && buttonStatePrevious == HIGH)
    {
      buttonStatePrevious = LOW;
      buttonStateLongPress = false;
      Serial.println("Button released");
      // If there is no measurement running to determine how long the button was pressed AND
      // If the time the button has been pressed is smaller than the minimal time needed for a long press
      // Note: The video shows:
      //       if (!buttonStateLongPress && buttonPressDuration < minButtonLongPressDuration) {
      //       since buttonStateLongPress is set to FALSE on line 75, !buttonStateLongPress is always TRUE
      //       and can be removed.
      if (buttonPressDuration < minButtonLongPressDuration)
      {
        Serial.println("Button pressed shortly");
      }
    }
    // store the current timestamp in previousButtonMillis
    previousButtonMillis = currentMillis;
  }
}
void send_email(const char *event)
{
  Serial.print("Connecting to ");
  Serial.println(host);
  // Use WiFiClient class to create TCP connections
  WiFiClient client;
  const int httpPort = 80;
  if (!client.connect(host, httpPort))
  {
    Serial.println("Connection failed");
    return;
  }
  // Creating a URL for the request
  String url = "/trigger/";
  url += event;
  url += "/with/key/";
  url += apiKey;
  Serial.print("Requesting URL: ");
  Serial.println(url);
  // This will send the request to the server
  client.print(String("GET ") + url + " HTTP/1.1\r\n" +
               "Host: " + host + "\r\n" +
               "Connection: close\r\n\r\n");
  while (client.connected())
  {
    if (client.available())
    {
      String line = client.readStringUntil('\r');
      Serial.print(line);
      oledDisplayCenter("SOS email sent!");
    }
    else
    {
      // No data yet, wait a bit
      delay(50);
    };
  }
  Serial.println();
  Serial.println("closing connection");
  client.stop();
}
void ring_alarm(int LED_BUILTIN, int time /* blink led for how long */)
{
  pinMode(LED_BUILTIN, OUTPUT);
  int time_count = 0;
  while (time_count < time && !digitalRead(pushButton))
  {
    oledDisplayCenter("Alarm Ringing!");
    digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level)
    delay(500);                      // wait for a second
    digitalWrite(LED_BUILTIN, LOW);  // turn the LED off by making the voltage LOW
    delay(500);                      // wait for a second
    time_count++;
  }
  oledDisplayCenter("Alarm turned off!");
  delay(3000);
}